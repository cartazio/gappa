<section>
<title>Rounding directions</title>

<para>Some of the classes of operators presented in the following sections are
templated by a rounding direction. This is the direction chosen when converting
a real number that cannot be exactly represented in the destination format.</para>

<para>There are four directions:</para>

<variablelist>
<varlistentry><term><code>zr</code></term><listitem>toward zero</listitem></varlistentry>
<varlistentry><term><code>dn</code></term><listitem>toward minus infinity (down)</listitem></varlistentry>
<varlistentry><term><code>up</code></term><listitem>toward plus infinity</listitem></varlistentry>
<varlistentry><term><code>ne</code></term><listitem>to nearest, tie breaking to even mantissas</listitem></varlistentry>
</variablelist>
</section>

<section>
<title>Floating-point operators</title>

<para>This class of operators covers all the formats whose number sets are
<texinline>F(p,d) = \{m \times 2^e; |m| &lt; 2^p, e \ge d\}</texinline>. In
particular, IEEE-754 floating-point formats (with subnormal numbers) are part
of this class, if we set apart overflow issues. Both parameters p and d select
a particular format. The last parameter selects the rounding direction.</para>

<programlisting><![CDATA[float< precision, minimum_exponent, rounding_direction >(...)]]></programlisting>

<para>Having to remember the precision and minimum exponent parameters may be
a bit tedious, so an alternate syntax is provided: instead of these two
parameters, a name can be given to the <code>float</code> class:</para>

<variablelist>
<varlistentry><term><code>ieee_32</code></term><listitem>IEEE-754 single precision</listitem></varlistentry>
<varlistentry><term><code>ieee_64</code></term><listitem>IEEE-754 double precision</listitem></varlistentry>
<varlistentry><term><code>ieee_128</code></term><listitem>IEEE-754 quadruple precision</listitem></varlistentry>
<varlistentry><term><code>x86_80</code></term><listitem>extended precision on x86-like processors</listitem></varlistentry>
</variablelist>

<programlisting><![CDATA[float< name, rounding_direction >(...)]]></programlisting>
</section>

<section>
<title>Fixed-point operators</title>

<para>This class of operators covers all the formats whose number sets are
<texinline>F(e) = \{m \times 2^e\}</texinline>. The first parameter selects
the weight of the least significant bit. The second parameter selects the
rounding direction.</para>

<programlisting><![CDATA[fixed< lsb_weight, rounding_direction >(...)]]></programlisting>

<para>Rounding to integer is a special case of fixed point rounding of weight
0. A syntactic shortcut is provided.</para>

<programlisting><![CDATA[int< rounding_direction >(...)]]></programlisting>
</section>

<section>
<title>Miscellaneous operators</title>
</section>

<section>
<title>Defining new functions</title>

<para>This section explains how rounding operators and functions are implemented
in Gappa. It is meant for developers rather than users of Gappa and involves
manipulating C++ classes defined in the <filename>src/arithmetic</filename>
directory.</para>

<section>
<title>Function classes</title>

<para>A function derives from the <code>function_class</code> class. This
class is an interface to the name of the function, its associated real
operator, and six theorems.</para>

<programlisting><![CDATA[struct function_class {
  real_op_type type;
  function_class(real_op_type t = UOP_ID): type(t) {}
  virtual std::string name() const = 0;
  virtual interval absolute_error_from_real   (interval const &, std::string &) const;
  virtual interval absolute_error_from_rounded(interval const &, std::string &) const;
  virtual interval relative_error_from_real   (interval const &, std::string &) const;
  virtual interval relative_error_from_rounded(interval const &, std::string &) const;
  virtual interval round                      (interval const &, std::string &) const;
  virtual interval enforce                    (interval const &, std::string &) const;
  virtual ~function_class() {}
};]]></programlisting>

<para>The name is a string given through the virtual method <code>name</code>.
It will be used when generating the notations of the proof. If the description
of the final function needs more than a name, additional parameters can be
provided by adding them to the name after a comma. The backend will take care
of the formatting of the final string.</para>

<para>The <code>type</code> is the associated real operator. This will be
<code>UOP_ID</code> (the unary identity function) for standard rounding
operators. But it can be more complex if needed:</para>

<programlisting><![CDATA[enum real_op_type { UOP_ID, UOP_NEG, UOP_ABS, BOP_ADD, BOP_SUB, BOP_MUL, BOP_DIV, ... };]]></programlisting>

<para>The type will indicate to the parser the number of arguments the function
requires. For example, if the <code>BOP_DIAM</code> type is associated to the
function <code>f</code>, then <code>f</code> will be parsed as a binary
function. But the type is also used by the rewriting engines in order to derive
default rules for this function. These rules involve the associated real
operator (the diamond in this example).</para>

<texinformal>f(a, b) - c \diamond d \quad\longrightarrow\quad
(f(a, b) - a \diamond b) + (a \diamond b - c \diamond d)</texinformal>
<texinformal>\frac{f(a, b) - c \diamond d}{c \diamond d} \quad\longrightarrow\quad
\frac{f(a, b) - a \diamond b}{a \diamond b} +
\frac{a \diamond b - c \diamond d}{c \diamond d} +
\frac{f(a, b) - a \diamond b}{a \diamond b} \cdot
\frac{a \diamond b - c \diamond d}{c \diamond d}</texinformal>

<para>For these rules and the following theorems to be useful, the expressions
<texinline>f(a, b)</texinline> and <texinline>a \diamond b</texinline> have to
be close to zero. Bounding their distance is the purpose of the last four
theorems. The first two theorems compute the range of <texinline>f(a, b)</texinline>
itself.</para>

<para>All the theorem virtual methods have a similar signature. If the result
is the undefined interval <code>interval()</code>, the theorem does not apply.
Otherwise, the last parameter is updated with the name of the theorem which
has to be applied. The proof generator will generate an internal node from the
two intervals and the name. As a side note, the ancestor method systematically
returns the undefined interval; this effectively disables the theorem.</para>

<variablelist>
<varlistentry><term><code>round</code></term>
<listitem>Given the range of <texinline>a \diamond b</texinline>, compute the
range of <texinline>f(a, b)</texinline>.</listitem></varlistentry>
<varlistentry><term><code>enforce</code></term>
<listitem>Given the range of <texinline>f(a, b)</texinline>, compute a stricter
range of it. For example, if this expression is an integer between 1.7 and 3.5,
then it is also a real number between 2 and 3.</listitem></varlistentry>
<varlistentry><term><code>absolute_error_from_real</code></term>
<listitem>Given the range of <texinline>a \diamond b</texinline>, compute the
range of <texinline>f(a, b) - a \diamond b</texinline>.</listitem></varlistentry>
<varlistentry><term><code>absolute_error_from_rounded</code></term>
<listitem>Given the range of <texinline>f(a, b)</texinline>, compute the
range of <texinline>f(a, b) - a \diamond b</texinline>.</listitem></varlistentry>
<varlistentry><term><code>relative_error_from_real</code></term>
<listitem>Given the range of <texinline>|a \diamond b|</texinline>, compute the
range of <texinline>\frac{f(a, b) - a \diamond b}{a \diamond b}</texinline>.</listitem></varlistentry>
<varlistentry><term><code>relative_error_from_rounded</code></term>
<listitem>Given the range of <texinline>|f(a, b)|</texinline>, compute the
range of <texinline>\frac{f(a, b) - a \diamond b}{a \diamond b}</texinline>.</listitem></varlistentry>
</variablelist>
</section>

<section>
<title>Function generators</title>

<para>Because functions can be templated by parameters. They have to be
generated by the parser on the fly. This is done by invoking the functional
method of an object derived from the <code>function_generator</code> class. A
fresh <code>function_class</code> object should not be generated each time;
they have to be cached so that they look identical.</para>

<programlisting><![CDATA[struct function_generator {
  function_generator(const char *);
  virtual function_class const *operator()(function_params const &) const = 0;
  virtual ~function_generator() {}
};]]></programlisting>

<para>The constructor of this class requires the name of the function template,
so that it gets registered by the parser. <code>operator()</code> is called
with a vector of encoded parameters.</para>

<para>If a function has no template parameters, the <code>default_function_generator</code>
class can be used instead to register it. The first parameter of the constructor
is the function name. The second one is the address of the
<code>function_class</code> object.</para>

<programlisting><![CDATA[default_function_generator::default_function_generator(const char *, function_class const *);]]></programlisting>
</section>

</section>

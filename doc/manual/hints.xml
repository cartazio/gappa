<section>
<title>Rewriting</title>

<para>Internally, Gappa tries to compute the range of mathematical terms. For
example, if the tool has to bound the product of two factors, it will check if
it knows the ranges of both factors. If it does, it will apply the theorem
about real multiplication in order to compute the range of the product.</para>

<para>Unfortunately, there may be some expressions that Gappa cannot bound
correctly. This usually happens because it has no result on a sub-term or
because the expression is badly correlated. In this case, the user can provide
an alternate expression. If Gappa finds an enclosure for this secondary
expression, it will use its range in an enclosure for the primary expression.</para>

<programlisting><![CDATA[primary -> secondary;]]></programlisting>

<para>In order for this transformation to be valid, any evaluation of the
primary expression must be contained in the enclosure of the secondary
expression. Gappa will generate the corresponding theorem in the final proof
script and its proof will be left as an exercise for the user.</para>

<para>This transformation is generally valid if both expressions are equal.
To detect mistyping early, Gappa will try to check if they are indeed equal and
warn if they are not. It will not generate a proof of their equality though and
it is still up to the user to do it. Note that Gappa does not check if the
divisor are always different from zero in the expressions. Instead it warn about
such potentially bad divisors.</para>

<para>The internal database of rules check for null divisors though. As a
consequence, if a common rule does not apply, this may mean that such a divisor
exists. In order to test whether it is the case or not, the
<code>-Munconstrained</code> option allows to skip these checks. If Gappa is
happy when this option is provided, the input should be checked for null
divisors. Note that this option obviously prevents the proof generation.</para>
</section>

<section>
<title>Approximations</title>

<para>As mentioned before, Gappa has an internal database of rewriting rules.
Some of these rules need to know about accurate and approximate terms. Without
this information, they do not match any expression. For example, Gappa will
replace the term <code>B</code> by <code>b + -(b - B)</code> only it knows a
term <code>b</code> that is an approximation of the term <code>B</code>.</para>

<para>Gappa has two heuristics to detect terms that are approximations of other
terms. First, rounded values are approximations of their non-rounded
counterparts. Second, any absolute or relative error that appears as a
hypothesis of a logical sub-formula will define a pair of accurate and
approximate terms.</para>

<para>Since these pairs create lots of already proved rewriting rules, it is
helpful for the user to define its own pairs. This can be done with the
following syntax.</para>

<programlisting><![CDATA[approximate ~ accurate;]]></programlisting>

<para>In the following example, the comments show two hints that could be added
if they had not already been guessed by Gappa. In particular, the second one
enables a rewriting rule that completes the proof.</para>

<programlisting><![CDATA[@floor = int<dn>;
{ x - y in [-0.1,0.1] -> floor(x) - y in ? }
# floor(x) ~ x;
# x ~ y;]]></programlisting>
</section>

<section>
<title>Bisection</title>

<para>The last kind of hint can be used when Gappa is unable to prove a formula
but would be able to prove it if the hypothesis ranges were not so wide. Such a
failure is usually caused by a bad correlation between the sub-terms of the
expressions. This can be solved by rewriting the expressions. But the failure
can also happen when the proof of the formula is not the same everywhere on the
domain. In both cases, the user can ask Gappa to split the ranges into tighter
ranges and see if it helps proving the formula.</para>

<para>a</para>

</section>

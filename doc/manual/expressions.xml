<section>
<title>Input sections</title>

<section>
<title>Logical formula</title>

<para>This is the fundamental part of the script, it contains the logical
formula Gappa is expected to prove. This formula is written between brackets
and can contain any implication, disjunction, conjunction of enclosures of
mathematical expressions. Enclosures are either bounded ranges or
inequalities. Any identifier without definition is assumed to be universally
quantified over the set of real numbers.</para>

<programlisting><![CDATA[{ x - 2 in [-2,0] /\ (x + 1 in [0,2] -> y in [3,4]) -> not x <= 1 \/ x + y in ? }]]></programlisting>

<para>The logical formula is first modified and loosely broken according to
the rules of sequent calculus. Each of the new formulas will then be verified
by Gappa. Ranges on the right of these sub-formulas can be left unspecified.
Gappa will then suggest a range such that the logical formula is verified.</para>

<programlisting><![CDATA[(1) x <= 1 /\ x - 2 in [-2,0] -> x + 1 in [0,2] \/ x + y in ?
(2) x <= 1 /\ x - 2 in [-2,0] /\ y in [3,4] -> x + y in ?]]></programlisting>

<para>In order to be useful in the proof of the whole formula, the second
sub-formula requires the first one to hold true. If Gappa cannot verify the
first sub-formula, it will skip the verification of the second one.</para>

<para>Inequalities can be present on both sides of a sub-formula. On the left,
it will be used only if Gappa is already able to compute an enclosure of the
expression by another way. On the right, Gappa will put a reverted copy on the
left if allowed by classical logic, in order to increase the number of
available hypotheses.</para>

<para>When proving a disjunction in a sub-formula, one of the sub-terms of this
disjunction has to always hold with respect to the set of hypotheses. If this
is not always the same sub-term that holds, Gappa will be unable to prove that
the whole disjunction holds.</para>
</section>

<section>
<title>Definitions</title>

<para>Typing the whole expressions in the logical formula can soon become
annoying and error-prone, especially if they contain rounding operators. To
ease this work, the user can define in another section beforehand the
expressions that will be used more than once. A special syntax also allows to
avoid embedding rounding operators everywhere.</para>

<para>First, rounding operators can be given a shorter name by using the
<code>@name = definition&lt;parameters&gt;</code> syntax. <code>name</code> can
then be used wherever the whole definition would have been used.</para>

<para>Next, common sub-terms of a mathematical expression can be shared by
giving them a name with the <code>name = term</code> syntax. This name can then
be used in later definitions or in the logical formula or in the hints. The
equality itself does not hold any semantic meaning. Gappa will only use the
name as a shorter expression when displaying the sub-term, and in the generated
proof instead of a randomly generated name.</para>

<para>Finally, when all the arithmetic operations on the right side of a
definition are followed by the same rounding operator, this operator can be
put once and for all on the left of the equal symbol. For example, with the
following script, Gappa will complain that <code>y</code> and <code>z</code>
are two different names for the same expression.</para>

<programlisting><![CDATA[@rnd = float< ieee_32, ne>;
y = rnd(x * rnd(1 - x));
z rnd= x * (1 - x);
{ y - z >= 0 }]]></programlisting>
</section>

<section>
<title>Hints</title>

<para>Hints for Gappa's engine can be added in this last section, if the tool
is not able to prove the logical formula. These hints are either rewriting
rules or bisection directives. Approximate and accurate expressions can also
be provided in this section in order to generate lots of safe rewriting
rules. Hints will be described in depth later.</para>
</section>

</section>

<section>
<title>Preferred expressions</title>

<para>Gappa rewrites expressions by matching them with well-known patterns. The
enclosure of an unmatchable expression will necessarily have to be computed
through interval arithmetic. As a consequence, to ensure that the expressions
will benefit from as much rewriting as possible, special care needs to be taken
when expressing the computational errors.</para>

<section>
<title>Absolute and relative errors</title>

<para>Let <code>exact</code> be an arithmetic expression and <code>approx</code>
an approximation of <code>exact</code>. The approximation usually contains
rounding operators while the exact expression does not. The absolute error
between these two expressions is their difference: <code>approx - exact</code>.
The relative error is the quotient between the absolute error and the exact
value: <code>(approx - exact) / exact</code>.</para>

<para>Writing the errors differently will prevent Gappa from applying
theorems on rounding errors: <code>-(x - rnd(x))</code> may lead to a
worse enclosure than <code>rnd(x) - x</code>.</para>
</section>

<section>
<title>Global errors</title>

<para>The <code>approx</code> and <code>exact</code> expressions need to have
a similar structure in order for the rewriting rules to kick in. E.g. if
<code>exact</code> is a sum of two terms <code>a</code> and <code>b</code>,
then <code>approx</code> has to be the sum of two terms <code>c</code> and
<code>d</code> such that <code>c</code> and <code>d</code> are approximations
of <code>a</code> and <code>b</code> respectively.</para>

<para>Indeed the rewriting rule for the absolute error of the addition is:
<code>(a + b) - (c + d) -&gt; (a - c) + (b - d)</code>. Similarly, the
rewriting rules for the multiplication keep the same ordering of sub-terms.
For example, one of the rules is:
<code>a * b - c * d -&gt; (a - c) * b + c * (b - d)</code>.</para>

<para>If the two sides of an error expression do not have a similar structure,
a user rewriting rule will have to be added in order to put them in a suitable
state.</para>
</section>

<section>
<title>Subsets of real numbers</title>

<para>Checking in the logical formula that an expression is in a
specific subset can be achieved by verifying that a rounding operator
toward this subset is the identity for this expression. For example, to
check that <code>e</code> is an integer multiple of <texinline>2^{-17}
</texinline>, this property can be used: <code>fixed&lt;-17, dn&gt;(e) -
e in [0,0]</code>. Similarly, to test that only 17 bits are needed to
represent this expression (assuming it is either zero or no closer to
zero than <texinline>2^{-2001}</texinline>): <code>float&lt;17, -2001,
ne&gt;(e) - e in [0,0]</code>.</para>
</section>

</section>

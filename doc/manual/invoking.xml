<section>
<title>Input and output</title>
<para>Gappa reads a script on its standard input. Such a script is made of
three parts: the definitions, the logical formula, and the hints. Warning
messages, error messages, and results are displayed on the standard error
output. Gappa sends to the standard output a formal proof of the logical
formula; its format depends on the selected back-end.</para>
<para>For example, the command-line below feeds Gappa with the
<filename>test.g</filename> file and stores the generated Coq proof script
in a <filename>test.v</filename> file. The proof can then be automatically
checked by the Coq proof assistant. Since nothing is displayed, it means no
errors were detected.</para>
<screen><![CDATA[$ echo "{ x in [-2,2] -> x * x in ? }" > test.g

$ gappa -Bcoq < test.g > test.v

Results for x in [-2, 2]:
x * x in [0, 1b2 {4, 2^(2)}]

$ coqc -I path/to/gappalib-coq test.v

$]]></screen>
</section>

<!-- ###### -->

<section>
<title>Command-line options</title>

<section>
<title>Selecting a proof back-end</title>

<para>These options are mutually exclusive and cannot be embedded into
scripts.</para>

<section>
<title>Null back-end.</title>
<para>Option: <code>-Bnull</code></para>
<para>Do not enable any back-end. This is the default.</para>
<para>This is also the only back-end compatible with the
<code>-Munconstrained</code> option.</para>
</section>

<section>
<title>Coq back-end</title>
<para>Option: <code>-Bcoq</code></para>
<para>When this back-end is selected, Gappa generates a script that proves the
results it displays. This script can be automatically verified by the Coq
proof-checker. It can also be reused in bigger formal developments made with
Coq.</para>
</section>

<section>
<title>HOL Light back-end</title>
<para>Option: <code>-Bholl</code></para>
<para>Similar to the previous option, but for the HOL Light proof-checker this
time.</para>
</section>

</section>

<section>
<title>Setting internal parameters</title>

<section>
<title>Internal precision</title>
<para>Option: <code>-Eprecision=</code><emphasis>integer</emphasis></para>
<para>This option sets the internal MPFR precision that Gappa uses when
computing bounds of intervals. The default value is 60 and should be sufficient
for most uses.</para>
</section>

<section>
<title>Dichotomy depth</title>
<para>Option: <code>-Edichotomy=</code><emphasis>integer</emphasis></para>
<para>This option limits the depth of a dichotomy split. The default value is
100. It means that an interval of width 1 is potentially split into 2^100
intervals of width 2^-100.</para>
</section>

<section>
<title>Fused multiply-add format</title>
<para>Option: <code>-E[no-]reverted-fma</code></para>
<para>By default (<code>-Eno-reverted-fma</code>), the expression
<code>fma(a,b,c)</code> is interpreted as <code>a * b + c</code>. As this may
not be the preferred order for the operands, the option makes Gappa use
<code>c + a * b</code> instead.</para>
</section>

</section>

<section>
<title>Setting modes</title>

<para>These options cannot be embedded into scripts.</para>

<section>
<title>Assuming vague hypotheses</title>
<para>Option: <code>-Munconstrained</code></para>
<para>By default, Gappa checks that all its hypotheses hold before using a
theorem. This mode weakens the engine by making it skip hypotheses that are not
needed for computing intermediate results. For example, Gappa will no longer
check that <code>x</code> is not zero before applying the lemma proving
<code>x / x in [1,1]</code>.</para>
<para>This mode is especially useful when starting a proof on relative errors,
as it makes it possible to get some early results about them without having to
prove that they are well-defined.</para>
<para>At the end of its run, Gappa displays all the facts that are left
unproven. In the example below, the property <code>NZR</code> means that a value
is not zero.</para>
<programlisting><![CDATA[{ x in [1,2] ->
  (x + 1) / (x + 1) in ? /\ (x - 1) / (x - 1) in ? }]]></programlisting>
<screen>Results for x in [1, 2]:
(x + 1) / (x + 1) in [1, 1]
(x - 1) / (x - 1) in [1, 1]
Unproven assumptions:
  NZR(x - 1)</screen>
<para>While Gappa only displays the properties that are left unproven at the end
of its run, it may contain false positive. This is especially true when one of
the unproven properties actually relies on the proof of another one. Both will
be displayed as unproven, although only the second one needs to be
proved.</para>
<para>This mode cannot be used when a proof back-end is selected.</para>
</section>

<section>
<title>Improving generated proofs</title>
<para>Option: <code>-Mexpensive</code></para>
<para>In this mode, Gappa tries to find shorter proofs. While this mode may
considerably slow down the computations, its effectiveness is far from being
guaranteed.</para>
</section>

<section>
<title>Gathering statistics</title>
<para>Option: <code>-Mstatistics</code></para>
<para>At the end of its computations, Gappa displays some statistics. For
example, the second script of this <link linkend="example-fixed">example</link>
gives:</para>
<screen>Statistics:
  4949 expressions were considered,
    but then 0 of these got discarded.
  14747 theorems were tried. Among these,
    5963 were successfully instantiated,
    yet 3247 of these were not good enough
    and 2 were only partially better.</screen>
<para>The first two lines show the amounts of intermediate expressions Gappa
prepared. The first number is the amount of expressions that were considered,
and the second number is the amount of expressions for which Gappa had not found
any usable theorem. Once this set of expressions is ready, Gappa tries to find
properties by applying theorems. The next statistics count these theorems.
First, the amount of theorems Gappa tried to apply. Then, among the theorems for
which Gappa could satisfy hypotheses, some gave a usable result, and some others
did not (because a better property was already proved at the time the theorem
was considered).</para>
</section>

</section>

<section>
<title>Enabling and disabling warning messages</title>
<para>By default, all the warning messages are enabled. See annex for details
on warning messages during <link linkend="warning-messages1">parsing</link>
and during <link linkend="warning-messages2">computations</link>.</para>
</section>

</section>

<!-- ###### -->

<section>
<title>Embedded options</title>
<para>Options setting internal parameters or enabling warning messages can be
embedded in a Gappa proof script. It is especially important when the logical
property cannot be proved with the default parameters. These options are passed
through a special comment syntax: <code>#@ -Edichotomy=200</code>.</para>
</section>

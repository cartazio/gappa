<section>
<title>Input and output</title>
<para>Gappa reads the script whose filename is passed as an argument to
the tool, or on its standard input if none. Such a script is made of
three parts: the definitions, the logical formula, and the hints. Warning
messages, error messages, and results, are displayed on the standard
error output. Gappa also sends to the standard output a formal proof of
the logical formula; its format depends on the selected back-end.
Finally, if the tool was unable to prove some goals, its return code is a
nonzero value.</para>

<para>For example, the following command lines create a simple script in
file <filename>test.g</filename>, pass it to Gappa, and store the
generated Coq proof in file <filename>test.v</filename> file. They also
test the return code of Gappa and send the generated proof to Coq so that
it is automatically checked. Since the proof checker does not display
anything, it means no errors were detected and the result computed by
Gappa is correct.</para>
<screen><![CDATA[$ echo "{ x in [-2,2] -> x * x in ? }" > test.g

$ gappa -Bcoq test.g > test.v

Results for x in [-2, 2]:
x * x in [0, 1b2 {4, 2^(2)}]

$ echo "Return code is $?"
Return code is 0

$ coqc -I path/to/gappalib-coq test.v

$]]></screen>
</section>

<!-- ###### -->

<section>
<title>Command-line options</title>

<section>
<title>Selecting a proof back-end</title>

<para>These options are mutually exclusive and cannot be embedded into
scripts.</para>

<section>
<title>Null back-end.</title>
<para>Option: <code>-Bnull</code></para>
<para>Do not enable any back-end. This is the default behavior. This is
also the only back-end compatible with the <code>-Munconstrained</code>
option.</para>
</section>

<section>
<title>Coq back-end</title>
<para>Option: <code>-Bcoq</code></para>
<para>When this back-end is selected, Gappa generates a script that proves the
results it displays. This script can be automatically verified by the Coq
proof-checker. It can also be reused in bigger formal developments made with
Coq.</para>
</section>

<section>
<title>HOL Light back-end</title>
<para>Option: <code>-Bholl</code></para>
<para>Similar to the previous option, but for the HOL Light proof-checker.</para>
</section>

<section>
<title>Coq lambda-term back-end</title>
<para>Option: <code>-Bcoq-lambda</code></para>
<para>This back-end is used by the <code>gappa</code> tactic available
for the Coq proof checker. It generates a lambda-term that can be
directly loaded by the proof checker, but it only supports the features
needed by the tactic: no bisection nor rewriting.</para>
</section>

</section>

<section>
<title>Setting internal parameters</title>

<section>
<title>Internal precision</title>
<para>Option: <code>-Eprecision=</code><emphasis>integer</emphasis></para>
<para>This option sets the internal MPFR precision that Gappa uses when
computing bounds of intervals. The default value is 60 and should be sufficient
for most uses.</para>
</section>

<section>
<title>Dichotomy depth</title>
<para>Option: <code>-Edichotomy=</code><emphasis>integer</emphasis></para>
<para>This option limits the depth of a dichotomy split. The default
value is 100. It means that an interval of width 1 is potentially split
into <texinline>2^{100}</texinline> intervals of width
<texinline>2^{-100}</texinline> relatively to the original interval. This
should be sufficient for most uses too.</para>
</section>

<section>
<title>Fused multiply-add format</title>
<para>Option: <code>-E[no-]reverted-fma</code></para>
<para>By default (<code>-Eno-reverted-fma</code>), the expression
<code>fma(a,b,c)</code> is interpreted as <code>a * b + c</code>. As this may
not be the preferred order for the operands, the option makes Gappa use
<code>c + a * b</code> instead.</para>
</section>

</section>

<section>
<title>Setting modes</title>

<para>These options cannot be embedded into scripts.</para>

<section>
<title>Assuming vague hypotheses</title>
<para>Option: <code>-Munconstrained</code></para>
<para>By default, Gappa checks that all its hypotheses hold before using a
theorem. This mode weakens the engine by making it skip hypotheses that are not
needed for computing intermediate results. For example, Gappa will no longer
check that <code>x</code> is not zero before applying the lemma proving
<code>x / x in [1,1]</code>.</para>
<para>This mode is especially useful when starting a proof on relative errors,
as it makes it possible to get some early results about them without having to
prove that they are well-defined.</para>
<para>At the end of its run, Gappa displays all the facts that are left
unproven. In the following example, the property <code>NZR</code>
indicates that Gappa possibly need to prove that a value (namely <code>x
- 1</code>, which appears as a denominator and is equal to zero for
<code>x</code> equal to 1) is nonzero.</para>
<programlisting language="gappa"><![CDATA[{ x in [1,2] ->
  (x + 1) / (x + 1) in ? /\ (x - 1) / (x - 1) in ? }]]></programlisting>
<screen>Results for x in [1, 2]:
(x + 1) / (x + 1) in [1, 1]
(x - 1) / (x - 1) in [1, 1]
Unproven assumptions:
  NZR(x - 1)</screen>
<para>While Gappa only displays the properties that are left unproven at the end
of its run, it may contain false positive. This is especially true when one of
the unproven properties actually relies on the proof of another one. Both will
be displayed as unproven, although only the second one needs to be
proved.</para>
<para>This mode cannot be used when a proof back-end is selected, as a
generated proof would contain holes.</para>
</section>

<section>
<title>Improving generated proofs</title>
<para>Option: <code>-Mexpensive</code></para>
<para>In this mode, Gappa tries to find shorter proofs. Although this
mode may considerably slow down the computations, its effectiveness is
unfortunately far from being guaranteed.</para>
</section>

<section>
<title>Gathering statistics</title>
<para>Option: <code>-Mstatistics</code></para>
<para>At the end of its computations, Gappa displays some statistics. For
example, the second script of <xref linkend="example-fixed"/>
gives:</para>
<screen>Statistics:
  2359 expressions were considered,
    but then 127 of those got discarded.
  6317 theorems were considered,
    but then 326 of those got discarded.
  7437 applications were tried. Among those,
    5933 were successful,
    yet 2626 proved useless
    and 13 improved existing results.</screen>
<para>The first two lines show how many intermediate expressions Gappa
has prepared. The first number tells how many have been considered, and
the second number tells how many of them were discarded because no
theorem could handle them. Similarly, the next two lines show how many
theorem instances Gappa has prepared. The first number tells how many
have been considered, and the second number tells how many of them were
discarded because their hypotheses could never have been satisfied.</para>
<para>Once both sets are ready, Gappa tries to deduce new properties by
repeatedly applying the prepared theorems. The next statistic show how
many of those theorems Gappa tried to apply. Applications are successful
if Gappa could satisfy theorem hypotheses. Even if an application succeeded,
the deduced property could have been (partly) useless because a stronger
property had already been found at the time the theorem was applied. The
last two lines track these cases.</para>
</section>

<section>
<title>Displaying propositions as Gappa scripts</title>
<para>Option: <code>-Msequent</code></para>
<para>Gappa applies several transformations to the input proposition if it is too complicated. The left-hand sides of the resulting sub-propositions (conjunction of atoms implying conjunctions and disjunctions of atoms) are then displayed in the results. This mode causes the propositions to be displayed in a syntax close to Gappa's one and with their right-hand side, so that one can work directly on the simpler sub-propositions.</para>
<programlisting language="gappa"><![CDATA[{ x in [0,1] \/ x in [2,3] -> not x + 1 in [0,1] }]]></programlisting>
<screen><![CDATA[Script:
  x in [1b1,3] /\
  x + 1 in [0,1] ->
  1 <= 0
Results:
A contradiction was built from the hypotheses.

Script:
  x in [0,1] /\
  x + 1 in [0,1] ->
  1 <= 0
Results:
Warning: no contradiction was found.]]></screen>
<para>Note that <code>1 &lt;= 0</code> is only there to complete the scripts, since they happen to not have any right-hand side, which means that Gappa tries to prove false from the hypotheses.</para>
</section>

</section>

<section>
<title>Enabling and disabling warning messages</title>
<para>By default, all the warning messages are enabled. See annex for details
on warning messages during <link linkend="warning-messages1">parsing</link>
and during <link linkend="warning-messages2">computations</link>.</para>
</section>

</section>

<!-- ###### -->

<section>
<title>Embedded options</title>
<para>Options setting internal parameters or enabling warning messages can be
embedded in a Gappa proof script. It is especially important when the logical
property cannot be proved with the default parameters. These options are passed
through a special comment syntax: <code>#@ -Edichotomy=200</code>.</para>
</section>

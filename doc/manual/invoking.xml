<section>
<title>Input and output</title>
<para>Gappa reads a script on its standard input. Such a script is made of
three parts: the definitions, the logical formula, and the hints. Warning
messages, error messages, and results are displayed on the standard error
output. Gappa sends to the standard output a formal proof of the logical
formula; its format depends on the selected back-end.</para>
<para>For example, the command-line below feeds Gappa with the
<filename>test.g</filename> file and stores the generated Coq proof script
in a <filename>test.v</filename> file. The proof can then be automatically
checked by the Coq proof assistant. Since nothing is displayed, it means no
errors were detected.</para>
<screen><![CDATA[$ echo "{ x in [-2,2] -> x * x in ? }" > test.g

$ gappa -Bcoq < test.g > test.v

Results for x in [-2, 2]:
x * x in [0, 1b2 {4, 2^(2)}]

$ coqc -I path/to/gappalib-coq test.v

$]]></screen>
</section>

<!-- ###### -->

<section>
<title>Command-line options</title>

<section>
<title>Selecting a back-end</title>

<para>These options are mutually exclusive and cannot be embedded into the
scripts.</para>

<section>
<title>Null back-end.</title>
<para>Option: <code>-Bnull</code></para>
<para>Do not enable any back-end. This is the default.</para>
<para>This is also the only back-end compatible with the
<code>-Munconstrained</code> option.</para>
</section>

<section>
<title>Coq back-end</title>
<para>Option: <code>-Bcoq</code></para>
<para>When this back-end is selected, Gappa generates a script that proves the
results it displays. This script can be automatically verified by the Coq
proof-checker. It can also be reused in bigger formal developments made with
Coq.</para>
</section>

<section>
<title>HOL Light back-end</title>
<para>Option: <code>-Bholl</code></para>
<para>Similar to the previous option, but for the HOL Light proof-checker this
time.</para>
</section>

</section>

<section>
<title>Setting internal parameters</title>

<section>
<title>Internal precision</title>
<para>Option: <code>-Eprecision=</code><emphasis>integer</emphasis></para>
<para>This option sets the internal MPFR precision that Gappa uses when
computing bounds of intervals. The default value is 60 and should be sufficient
for most uses.</para>
</section>

<section>
<title>Dichotomy depth</title>
<para>Option: <code>-Edichotomy=</code><emphasis>integer</emphasis></para>
<para>This option limits the depth of a dichotomy split. The default value is
100. It means that an interval of width 1 is potentially split into 2^100
intervals of width 2^-100.</para>
</section>

<section>
<title>Fused multiply-add format</title>
<para>Option: <code>-E[no-]reverted-fma</code></para>
<para>By default (<code>-Eno-reverted-fma</code>), the expression
<code>fma(a,b,c)</code> is interpreted as <code>a * b + c</code>. As this may
not be the preferred order for the operands, the option makes Gappa use
<code>c + a * b</code> instead.</para>
</section>

</section>

<section>
<title>Setting modes</title>

<para>To be written.</para>
</section>

<section>
<title>Enabling and disabling warning messages</title>
<para>By default, all the warning messages are enabled. See annex for details
on warning messages during <link linkend="warning-messages1">parsing</link>
and during <link linkend="warning-messages2">computations</link>.</para>
</section>

</section>

<!-- ###### -->

<section>
<title>Embedded options</title>
<para>Options setting internal parameters or enabling warning messages can be
embedded in a Gappa proof script. It is especially important when the logical
property cannot be proved with the default parameters. These options are passed
through a special comment syntax: <code>#@ -Edichotomy=200</code>.</para>
</section>

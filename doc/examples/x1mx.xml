<section>
<title>A simple example to start from</title>

<section>
<title>The C program</title>

<para>Let us analyze the following function.</para>

<programlisting><![CDATA[float f(float x) {
  assert(0 <= x && x <= 1);
  return x * (1 - x);
}]]>
</programlisting>

<para>This function computes the value $x \cdot (1 - x)$ for an argument $x$
between $0$ and $1$. The <type>float</type> type is meant to force the compiler
to use IEEE-754 single precision floating-point numbers. We will also assume
that the default rounding mode is used: rounding to nearest number, break to
even on tie.</para>

<para>The function returns the value $x \otimes (1 \ominus x)$ instead of the
ideal value $x \cdot (1 - x)$ due to the limited precision of the
computations. If we rule out the overflow possibility (floating-point numbers
are limited, not only in precision, but also in range), the returned value is
also $\circ(x \cdot \circ(1 - x))$. $\circ$ is a unary operator related to
the floating-point format and the rounding mode used for the computations.
This is the form Gappa works on.</para>
</section>

<section>
<title>First Gappa version</title>

<para>We will first try to bound the result of the function. Knowing that $x$
is in the interval $[0,1]$, what is the enclosing interval of the function
result? It can be expressed as an implication: if $x \in [0,1]$, then the
result is in ... something. Since we do not want to enforce some specific
bounds yet, we will just note this interval <code>?</code> for now.</para>

<para>The logical formula Gappa has to verify is enclosed between braces. The
rounding operator is noted between angles. <code>float32ne</code> means:
standard floating-point format stored on 32 bits (IEEE-754 single precision
format) with rounding to nearest even. The following Gappa line will ask Gappa
to find an interval such that the logical formula describing our previous
function is true.</para>

<programlisting><![CDATA[{ x in [0,1] -> <float32ne>(x * <float32ne>(1 - x)) in ? }]]>
</programlisting>

<para>Gappa will answer that the result is between 0 and 1. Without any help
from the user, they are the best bounds Gappa will be able to reach.</para>

<programlisting><![CDATA[$ echo "{ x in [0,1] -> <float32ne>(x * <float32ne>(1 - x)) in ? }" | src/gappa > /dev/null

<float32ne>(x * <float32ne>(1 - x)) in [0 {-0}, 1 {1}]]]>
</programlisting>

<para>Gappa will display the bounds it has reached. The numbers between braces
are an approximation of the numbers on their left. These exact left numbers are
written in decimal with a power-of-two exponent. The precise format will be
described below.</para>
</section>

<section>
<title>Complete version</title>

<para>We will now see some way to expand Gappa's search space in order for it
to find better bounds. Not only Gappa will be able provide a proof of the
optimal bounds for the result of the function, but it will also verify a tight
interval on the computational absolute error.</para>

<section>
<title>Notations</title>

<para>The whole mathematical description of a problem can simply be written in
Gappa's logical formulas. But it may become tedious once the problem gets big
enough. For this reason, notations can be defined to avoid repeating the same
terms over and over. These notations are all written before the logical
formula.</para>

<programlisting><![CDATA[x = <float32ne>(xx);             # x is a floating-point number
y <float32ne>= x * (1 - x);      # means y = <f32..>(x * <f32..>(1 - x))
z = x * (1 - x);]]>
</programlisting>

<para>The syntax of the notations is simple: the left hand side is a name
representing the expression on the right hand side. Using one or the other side
in the logical formula will make no difference, both are equivalents. Gappa
will use the left hand side when displaying the results and generating the
proofs though, in order to make them more readable. The third notation will
simply define <code>z</code> as a synonym for the right hand side
<code>x * (1 - x)</code>.</para>

<para>The first notation defines <code>x</code> as the rounded value of a real
number <code>xx</code>. In the previous example, we had not expressed this
property of <code>x</code>: it is a floating-point number. This additional
piece of information will help Gappa to improve the bound on the error bound.
</para>

<para>The second notation gives a name to the result of the function. The
syntax <code>&lt;..&gt;=</code> implicitly applies the rounding operator to the
result of any operation in the right hand side. Please note that it only
applies if operation there is. In particular, <code>a &lt;..&gt;= b</code> is
not equivalent to <code>a = &lt;..&gt;(b)</code>; it is equivalent to
<code>a = b</code>.</para>
</section>

<section>
<title>Logical formulas and numbers</title>

<programlisting><![CDATA[{ x in [0,1] -> y in [0,0.25] /\ y - z in [-3b-27,3b-27] }]]>
</programlisting>

<para>Numbers and bounds can be written either in the usual scientific decimal
notation or by using a power-of-two exponent: <code>3b-27</code> means
$3 \cdot 2^{-27}$.</para>
</section>

<section>
<title>Hints</title>

<para>Although we added one additional through the type of <code>x</code>,
Gappa will not be able to prove the formula. It needs some user hints.</para>

<programlisting><![CDATA[z -> 0.25 - (x - 0.5) * (x - 0.5);     # x * (1 - x) == 1/4 - (x - 1/2)^2
y $ x;                                 # bound y by splitting the interval on x
y - z $ x;                             # bound y - z by splitting ...]]>
</programlisting>

<para>The first hint indicates to Gappa that both hand sides are equivalent:
when it tries to bound the left hand side, it can use the bounds on the right
hand side. Please note that this rewriting only applies when Gappa tries to
bound the expression, not when it tries to bound a bigger expression.</para>

<para>The two other hints indicate that Gappa should bound the left hand sides
by doing a case split on the right hand side. It only works if the user
asked for explicit bounds on the left hand side, otherwise the first interval
reached is used.</para>
</section>

<section>
<title>Full listing</title>

<para>And to conclude this example, here is the full listing.</para>

<programlisting><![CDATA[# some notations
x = <float32ne>(xx);                   # x is a floating-point number
y <float32ne>= x * (1 - x);            # means y = <f32..>(x * <f32..>(1 - x))
z = x * (1 - x);

# the logical property
{ x in [0,1] -> y in [0,0.25] /\ y - z in [-3b-27,3b-27] }

# hints
z -> 0.25 - (x - 0.5) * (x - 0.5);     # x * (1 - x) == 1/4 - (x - 1/2)^2
y $ x;                                 # bound y by splitting the interval on x
y - z $ x;                             # bound y - z by splitting ...]]>
</programlisting>
</section>

</section>
</section>

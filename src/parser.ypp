%{

#include <iostream>
#include "ast.hpp"
#include "program.hpp"

int yylex(void);

int yyerror(char* errstr) {
    std::cerr << "Error: " << errstr << std::endl;
    return EXIT_FAILURE;
}

extern ast_real *check_real(ast_ident *v);
extern variable *check_prog_variable(ast_ident *v, type_id t = UNDEFINED, instruction *ins = NULL);
extern real_variable *check_real_variable(ast_ident *v, ast_real *r);
extern ast_prop_and merge_prop_and(ast_prop const &p1, ast_prop const &p2);
extern void generate_graph(ast_prop const &p, ast_prop_and const &r);
extern void link_variables();

static ast_prop_and implicit;

%}

%error-verbose

%token IDENT NUMBER ERROR IN AND IMPL ASSIGN

%union {
  ast_number	*number;
  ast_ident	*ident;
  ast_interval	interval;
  ast_real	*real;
  ast_operands	*operands;
  ast_prop	*prop;
  int toto;
}

%type <prop>      ATOM
%type <number>    NUMBER
%type <ident>     IDENT
%type <interval>  INTERVAL
%type <toto>      ERROR
%type <real>      REAL
%type <operands>  OPERANDS
%type <prop>      PROP

%right IMPL
%left AND
%left '+' '-'
%left '*' '/'

%%

BLOB: PROG REALS '{' PROP '}'	{ link_variables(); generate_graph(*$4, implicit); delete $4; }

PROP:
  ATOM			{ $$ = $1; }
| '(' PROP ')'		{ $$ = $2; }
| PROP AND PROP		{ $$ = $1; *$1 = merge_prop_and(*$1, *$3); delete $3; }
| PROP IMPL PROP
  {
    if (ast_prop_impl *p = boost::get< ast_prop_impl >($3)) {
      p->left = merge_prop_and(*$1, p->left);
      delete $1;
      $$ = $3;
    } else {
      ast_prop_impl p;
      p.left = *$1;
      p.right = *$3;
      *$1 = p;
      delete $3;
      $$ = $1;
    }
  }

INTERVAL:
  '[' NUMBER ',' NUMBER ']'	{ ast_interval i = { $2, $4 }; $$ = i; }
| '?'				{ ast_interval i = { NULL, NULL }; $$ = i; }

ATOM:
  REAL IN INTERVAL
  { $$ = new ast_prop(ast_atom_bound($1, $3)); }
| ERROR '(' IDENT ',' REAL ')' IN INTERVAL
  { $$ = new ast_prop(ast_atom_error($1, check_prog_variable($3), $5, $8)); }

PROG: OPERATION | PROG OPERATION

OPERATION:
  IDENT ASSIGN IDENT '(' OPERANDS ')' ';'
  {
    ast_ident *f = $3;
    function *fun = f->fun;
    if (!fun)
      { std::cerr << "Error: " << f->name << " is not a function" << '\n'; exit(1); }
    ast_operands *ops = $5;
    instruction *ins = new instruction;
    ins->fun = fun;
    int l = ops->ops.size();
    for(int i = 0; i < l; ++i) {
      if (fun->args_type[i] == UNDEFINED)
        { std::cerr << "Error: Too many arguments for " << f->name << '\n'; exit(1); }
      ins->in.push_back(check_prog_variable(ops->ops[i], fun->args_type[i]));
    }
    if (fun->args_type[l] != UNDEFINED)
      { std::cerr << "Error: Too few arguments for " << f->name << '\n'; exit(1); }
    ins->out.push_back(check_prog_variable($1, fun->return_type[0], ins));
    program.push_back(ins);
    delete ops;
  }
| IDENT ASSIGN IDENT ';'
  {
    instruction *ins = new instruction;
    ins->fun = NULL;
    ins->in.push_back(check_prog_variable($3));
    ins->out.push_back(check_prog_variable($1, $3->var->type, ins));
    program.push_back(ins);
  }
| IDENT ASSIGN NUMBER ';'
  { implicit = merge_prop_and(implicit, ast_atom_approx(check_prog_variable($1), $3)); }

REALS: | REALS NEWREAL

NEWREAL:
  IDENT '=' REAL ';'	{ check_real_variable($1, $3); }

REAL:
  NUMBER		{ $$ = new ast_real($1); }
| IDENT			{ $$ = check_real($1); }
| '+' REAL		{ $$ = $2; }
| '-' REAL		{ $$ = normalize(ast_real(real_op(UOP_MINUS, $2))); }
| REAL '+' REAL		{ $$ = normalize(ast_real(real_op($1, BOP_ADD, $3))); }
| REAL '-' REAL		{ $$ = normalize(ast_real(real_op($1, BOP_SUB, $3))); }
| REAL '*' REAL		{ $$ = normalize(ast_real(real_op($1, BOP_MUL, $3))); }
| REAL '/' REAL		{ $$ = normalize(ast_real(real_op($1, BOP_DIV, $3))); }
| '(' REAL ')'		{ $$ = $2; }

OPERANDS:
  IDENT
  {
    ast_operands *o = new ast_operands;
    o->ops.push_back($1);
    $$ = o;
  }
| OPERANDS ',' IDENT
  {
    ast_operands *o = $1;
    o->ops.push_back($3);
    $$ = o;
  }

%{

#include <iostream>
#include <map>
#include <string>
#include <gmp.h>
#include "parser/ast.hpp"
#include "parser/parser.h"

static void read_number(YYSTYPE *yylval) {
  int dec = -1;
  char const *ptr = yytext;
  bool hexa = ptr[1] == 'x'; // valid offset
  if (hexa) ptr += 2;
  ast_number num;
  for(; *ptr; ++ptr) {
    char c = *ptr;
    if (c == '.') { dec = 0; continue; }
    if (c >= 'a') c += 'A' - 'a';
    if (hexa ? (c == 'P') : (c > '9')) break;
    if (dec >= 0) ++dec;
    num.mantissa += c;
  }
  switch (*ptr) {
  case 'b': case 'B': case 'p': case 'P': ++ptr; num.base = 2; break;
  case 'e': case 'E': ++ptr; num.base = 10; break;
  default: num.base = hexa ? 2 : 10;
  }
  if (*ptr) num.exponent = atoi(ptr);
  else num.exponent = 0;
  if (dec > 0) num.exponent -= hexa ? dec * 4 : dec;
  mpz_t m;
  mpz_init(m);
  mpz_set_str(m, num.mantissa.c_str(), hexa ? 16 : 10);
  char *s = mpz_get_str(NULL, 10, m);
  num.mantissa = s[0] == '-' ? std::string(s) : std::string(1, '+') + s;
  free(s);
  mpz_clear(m);
  yylval->number = normalize(num);
}

static void read_zero(YYSTYPE *yylval) {
  ast_number num;
  num.base = 0;
  num.exponent = 0;
  yylval->number = normalize(num);
}

static void read_ident(YYSTYPE *yylval) {
  yylval->ident = ast_ident::find(yytext);
}

extern bool parse_option(std::string const &, bool);

static void read_options(YYLTYPE &yylloc) {
  std::string s = yytext;
  std::string::size_type begin, end = 2;
  while ((begin = s.find_first_not_of(" \t", end)) != std::string::npos) {
    end = s.find_first_of(" \t", begin);
    if (end == std::string::npos) end = s.size();
    std::string o = s.substr(begin, end - begin);
    if (!parse_option(o, true)) {
      std::cerr << "Error: unrecognized option '" << o << "' at line " << yylloc.first_line << '\n';
      exit(EXIT_FAILURE);
    }
  }
}

#define YY_USER_INIT	{ yylloc->first_line = 1; yylloc->first_column = 0; }
#define YY_USER_ACTION	yylloc->first_column += yyleng;

%}

%option noyywrap
%option bison-locations

alpha	[a-zA-Z]
digit	[0-9]

ident		{alpha}({alpha}|{digit}|_)*
integer		{digit}+
hexa		[0-9a-fA-F]+
binary		{integer}([bB][-+]?{integer})?
decimal		(({integer}(\.{integer}?)?)|(\.{integer}))([eE][-+]?{integer})?
hexadecimal	0x(({hexa}(\.{hexa}?)?)|(\.{hexa}))([pP][-+]?{integer})?
number		({binary}|{decimal}|{hexadecimal})
zero		((((0+(\.0*)?)|(\.0+))([eE][-+]?{integer})?)|0x(((0+(\.0*)?)|(\.0+))([pP][-+]?{integer})?)|(0+([bB][-+]?{integer})?))

%%

[ \t]
\n		{ ++yylloc->first_line; yylloc->first_column = 0; }
#@[^\n]*	read_options(*yylloc);
#[^\n]*
"/\\"		return AND;
"->"		return IMPL;
"in"		return IN;
{zero}		{ read_zero(yylval);	return NUMBER; }
{number}	{ read_number(yylval);	return NUMBER; }
{ident}		{ read_ident(yylval);	return IDENT;  }
.		return yytext[0];

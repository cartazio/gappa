%{
#include <iostream>

#include "parser/ast.hpp"
#include "parser/parser.h"
#include "proofs/basic_proof.hpp"
#include "proofs/dichotomy.hpp"

#define yyerror(msg) my_yyerror(yylloc, msg)

int yylex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param);

#define error(msg) \
  std::cerr << "Error: " << msg << " at line " << yylloc.first_line << " column " << yylloc.first_column << '\n'
#define warning(msg) \
  std::cerr << "Warning: " << msg << " at line " << yylloc.first_line << " column " << yylloc.first_column << '\n'

int my_yyerror(YYLTYPE &yylloc, char const *errstr) {
    error(errstr);
    return EXIT_FAILURE;
}

#define failure(msg) do {\
  error(msg); \
  YYERROR; \
} while (0)

extern void generate_graph(ast_prop const *p);
extern void test_ringularity(ast_real const *, ast_real const *);
extern std::set< ast_real const * > free_variables;

ast_number *negative_number(ast_number *nn) {
  if (nn->base == 0) return nn;
  ast_number n = *nn;
  char &c = n.mantissa[0];
  assert(c == '+');
  c = '-';
  return normalize(n);
}

static function_class const *rounding_mode = NULL;

static ast_real const *rnd_normalize(ast_real const &real) {
  ast_real const *r = normalize(real);
  if (!rounding_mode) return r;
  return normalize(ast_real(real_op(rounding_mode, r)));
}

#define YYINCLUDED_STDLIB_H

%}

%error-verbose
%pure-parser
%locations

%token IDENT IN NUMBER SQRT

%union {
  ast_number		*number;
  ast_ident		*ident;
  ast_interval		interval;
  ast_real const	*real;
  ast_real_vect		*operands;
  ast_prop		*prop;
  function_class const	*function;
  function_params	*params;
  unsigned long		param;
}

%type <number>		NUMBER
%type <number>		SNUMBER
%type <ident>		IDENT
%type <interval>	INTERVAL
%type <real>		REAL
%type <operands>	OPERANDS
%type <prop>		PROP
%type <function>	FUNCTION
%type <params>		FUNCTION_PARAMS
%type <params>		FUNCTION_PARAMS_AUX
%type <param>		FUNCTION_PARAM

%right IMPL
%left OR
%left AND
%left NOT
%left '+' '-'
%left '*' '/'
%left NEG

%%

BLOB: PROG '{' PROP '}' HINTS		{ generate_graph($3); }

PROP:
  REAL IN INTERVAL	{ $$ = new ast_prop(new ast_atom_bound($1, $3)); }
| PROP AND PROP		{ $$ = new ast_prop($1, PROP_AND,  $3); }
| PROP OR PROP		{ $$ = new ast_prop($1, PROP_OR,   $3); }
| PROP IMPL PROP	{ $$ = new ast_prop($1, PROP_IMPL, $3); }
| NOT PROP		{ $$ = new ast_prop($2); }
| '(' PROP ')'		{ $$ = $2; }

SNUMBER:
  NUMBER	{ $$ = $1; }
| '+' NUMBER	{ $$ = $2; }
| '-' NUMBER	{ $$ = negative_number($2); }

INTERVAL:
  '[' SNUMBER ',' SNUMBER ']'	{ ast_interval i = { $2, $4 }; $$ = i; }
| '?'				{ ast_interval i = { NULL, NULL }; $$ = i; }

FUNCTION_PARAM:
  SNUMBER	{ $$ = (unsigned long)(atoi($1->mantissa.c_str()) * 2) | 1; }
| IDENT		{ $$ = (unsigned long)($1); }

FUNCTION_PARAMS_AUX:
  FUNCTION_PARAM	{ $$ = new function_params(1, $1); }
| FUNCTION_PARAMS_AUX ',' FUNCTION_PARAM
  {
    function_params *p = $1;
    p->push_back($3);
    $$ = p;
  }

FUNCTION_PARAMS:
  { $$ = NULL; }
| '<' FUNCTION_PARAMS_AUX '>'	{ $$ = $2; }

FUNCTION:
  IDENT FUNCTION_PARAMS
  {
    ast_ident *r = $1;
    if (r->type != ID_FUN) failure(r->name << " is not a function");
    function_class const *f;
    if (function_params *p = $2) {
      f = (*r->fun)(*p);
      delete p;
    } else f = (*r->fun)(function_params());
    if (!f) failure("invalid parameters for " << r->name);
    $$ = f;
  }

EQUAL:
  '='
| FUNCTION '='
  {
    function_class const *f = $1;
    if (f->type != UOP_ID) failure(f->name() << " is not a rounding operator");
    rounding_mode = f;
  }

PROG:
| PROG IDENT EQUAL REAL ';'
  {
    ast_ident *v = $2;
    if (v->type != ID_NONE) failure("the symbol " << v->name << " is redefined");
    ast_real const *r = $4;
    v->type = ID_VAR;
    v->var = r;
    if (r->name) warning(r->name->name << " is being renamed to " << v->name);
    r->name = v;
    rounding_mode = NULL;
  }
| PROG '@' IDENT '=' FUNCTION ';'
  {
    ast_ident *v = $3;
    if (v->type != ID_NONE) failure("the symbol " << v->name << " is redefined");
    v->type = ID_FUN;
    v->fun = new default_function_generator($5);
  }

REAL:
  SNUMBER	{ $$ = normalize(ast_real($1)); }
| IDENT
  {
    ast_ident *v = $1;
    switch (v->type) {
    case ID_FUN: failure(v->name << " is not a variable");
    case ID_VAR: break;
    case ID_NONE:
      v->type = ID_VAR;
      ast_real *r = normalize(ast_real(v));
      free_variables.insert(r);
      v->var = r;
    }
    $$ = v->var;
  }
| FUNCTION '(' OPERANDS ')'
  {
    function_class const *f = $1;
    ast_real_vect *ops = $3;
    if (f->type == UOP_ID && ops->size() != 1 || f->type != UOP_ID && ops->size() != 2)
      failure("incorrect number of arguments when calling " << f->name());
    $$ = normalize(ast_real(real_op(f, *ops)));
    delete ops;
  }
| REAL '+' REAL		{ $$ = rnd_normalize(ast_real(real_op($1, BOP_ADD, $3))); }
| REAL '-' REAL		{ $$ = rnd_normalize(ast_real(real_op($1, BOP_SUB, $3))); }
| REAL '*' REAL		{ $$ = rnd_normalize(ast_real(real_op($1, BOP_MUL, $3))); }
| REAL '/' REAL		{ $$ = rnd_normalize(ast_real(real_op($1, BOP_DIV, $3))); }
| '|' REAL '|'		{ $$ = rnd_normalize(ast_real(real_op(UOP_ABS, $2))); }
| SQRT '(' REAL ')'	{ $$ = rnd_normalize(ast_real(real_op(UOP_SQRT, $3))); }
| '(' REAL ')'		{ $$ = $2; }
| '+' REAL %prec NEG	{ $$ = $2; }
| '-' REAL %prec NEG	{ $$ = rnd_normalize(ast_real(real_op(UOP_NEG, $2))); }

OPERANDS:
  REAL		{ $$ = new ast_real_vect(1, $1); }
| OPERANDS ',' REAL
  {
    $1->push_back($3);
    $$ = $1;
  }

HINTS:
| HINTS REAL IMPL REAL ';'
  {
    ast_real const *r1 = $2, *r2 = $4;
    test_ringularity(r1, r2);
    register_user_rewrite(r1, r2);
  }
| HINTS OPERANDS '$' OPERANDS ';'
  {
    dichotomy_hint h;
    h.dst = *$2; delete $2;
    h.src = *$4; delete $4;
    dichotomies.push_back(h);
  }
| HINTS '$' OPERANDS ';'
  {
    dichotomy_hint h;
    h.src = *$3; delete $3;
    dichotomies.push_back(h);
  }
| HINTS REAL '~' REAL ';'
  {
    ast_real const *r1 = $2, *r2 = $4;
    if (r1->accurate) failure("the accurate expression of " << dump_real(r1) << " is modified");
    r1->accurate = r2;
  }

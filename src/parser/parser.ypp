%{
#include <iostream>

#include "parser/ast.hpp"
#include "proofs/dichotomy.hpp"
#include "parser/parser.h"
#include "proofs/basic_proof.hpp"

#define yyerror(msg) my_yyerror(yylloc, msg)

int yylex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param);

#define error(msg) \
  std::cerr << "Error: " << msg << " at line " << yylloc.first_line << " column " << yylloc.first_column << '\n'
#define warning(msg) \
  std::cerr << "Warning: " << msg << " at line " << yylloc.first_line << " column " << yylloc.first_column << '\n'

int my_yyerror(YYLTYPE &yylloc, char const *errstr) {
    error(errstr);
    return EXIT_FAILURE;
}

#define failure(msg) do {\
  error(msg); \
  YYERROR; \
} while (0)

extern void generate_graph(ast_prop const *p);
extern void test_ringularity(ast_real const *, ast_real const *);
extern int test_rewriting(ast_real const *, ast_real const *, std::string &);
extern std::set< ast_real const * > free_variables;
extern bool parameter_rfma;

static ast_number const *negative_number(ast_number const *nn) {
  if (nn->base == 0) return nn;
  ast_number n = *nn;
  char &c = n.mantissa[0];
  assert(c == '+');
  c = '-';
  return normalize(n);
}

static function_class const *rounding_mode = NULL;

static ast_real const *rnd_normalize(ast_real const &real) {
  ast_real const *r = normalize(real);
  if (!rounding_mode) return r;
  return normalize(ast_real(real_op(rounding_mode, r)));
}

#define scan_integer(n,res) \
  if (n->exponent != 0 || n->mantissa.size() >= 7) failure("the number does not look like an integer"); \
  unsigned long res = (unsigned long)(atoi(n->mantissa.c_str()) * 2) | 1;

#define YYINCLUDED_STDLIB_H

%}

%error-verbose
%pure-parser
%locations

%token IDENT IN NUMBER SQRT FMA LE GE

%union {
  ast_number const	*number;
  ast_ident		*ident;
  ast_real const	*real;
  ast_real_vect		*reals;
  dichotomy_var		dvar;
  dvar_vect		*dvars;
  ast_prop		*prop;
  function_class const	*function;
  function_params	*params;
  unsigned long		param;
}

%type <number>		NUMBER
%type <number>		SNUMBER
%type <ident>		IDENT
%type <real>		REAL
%type <reals>		REALS
%type <dvar>		DVAR
%type <dvars>		DVARS
%type <param>		DPOINTS
%type <prop>		PROP
%type <function>	FUNCTION
%type <params>		FUNCTION_PARAMS
%type <params>		FUNCTION_PARAMS_AUX
%type <param>		FUNCTION_PARAM

%right IMPL
%left OR
%left AND
%left NOT
%left '+' '-'
%left '*' '/'
%left NEG

%%

BLOB: BLOB1 HINTS
BLOB1: PROG '{' PROP '}'	{ generate_graph($3); }

PROP:
  REAL LE SNUMBER
  {
    real_op const *p = boost::get< real_op const >($1);
    $$ = new ast_prop(new ast_atom_bound($1, (!p || p->type != UOP_ABS) ? NULL : token_zero, $3));
  }
| REAL IN '[' SNUMBER ',' SNUMBER ']'
  			{ $$ = new ast_prop(new ast_atom_bound($1, $4, $6)); }
| REAL IN '?'		{ $$ = new ast_prop(new ast_atom_bound($1, NULL, NULL)); }
| REAL GE SNUMBER	{ $$ = new ast_prop(new ast_atom_bound($1, $3, NULL)); }
| PROP AND PROP		{ $$ = new ast_prop($1, PROP_AND,  $3); }
| PROP OR PROP		{ $$ = new ast_prop($1, PROP_OR,   $3); }
| PROP IMPL PROP	{ $$ = new ast_prop($1, PROP_IMPL, $3); }
| NOT PROP		{ $$ = new ast_prop($2); }
| '(' PROP ')'		{ $$ = $2; }

SNUMBER:
  NUMBER	{ $$ = $1; }
| '+' NUMBER	{ $$ = $2; }
| '-' NUMBER	{ $$ = negative_number($2); }

FUNCTION_PARAM:
  SNUMBER	{ scan_integer($1, v); $$ = v; }
| IDENT		{ $$ = reinterpret_cast< unsigned long >($1); }

FUNCTION_PARAMS_AUX:
  FUNCTION_PARAM	{ $$ = new function_params(1, $1); }
| FUNCTION_PARAMS_AUX ',' FUNCTION_PARAM
  {
    function_params *p = $1;
    p->push_back($3);
    $$ = p;
  }

FUNCTION_PARAMS:
  { $$ = NULL; }
| '<' FUNCTION_PARAMS_AUX '>'	{ $$ = $2; }

FUNCTION:
  IDENT FUNCTION_PARAMS
  {
    ast_ident *r = $1;
    if (r->type != ID_FUN) failure(r->name << " is not a function");
    function_class const *f;
    if (function_params *p = $2) {
      f = (*r->fun)(*p);
      delete p;
    } else f = (*r->fun)(function_params());
    if (!f) failure("invalid parameters for " << r->name);
    $$ = f;
  }

EQUAL:
  '='
| FUNCTION '='
  {
    function_class const *f = $1;
    if (f->type != UOP_ID) failure(f->name() << " is not a rounding operator");
    rounding_mode = f;
  }

PROG:
| PROG IDENT EQUAL REAL ';'
  {
    ast_ident *v = $2;
    if (v->type != ID_NONE) failure("the symbol " << v->name << " is redefined");
    ast_real const *r = $4;
    v->type = ID_VAR;
    v->var = r;
    if (r->name) warning(r->name->name << " is being renamed to " << v->name);
    r->name = v;
    rounding_mode = NULL;
  }
| PROG '@' IDENT '=' FUNCTION ';'
  {
    ast_ident *v = $3;
    if (v->type != ID_NONE) failure("the symbol " << v->name << " is redefined");
    v->type = ID_FUN;
    v->fun = new default_function_generator($5);
  }

REAL:
  SNUMBER	{ $$ = normalize(ast_real($1)); }
| IDENT
  {
    ast_ident *v = $1;
    switch (v->type) {
    case ID_FUN: failure(v->name << " is not a variable");
    case ID_VAR: break;
    case ID_NONE:
      v->type = ID_VAR;
      ast_real *r = normalize(ast_real(v));
      free_variables.insert(r);
      v->var = r;
    }
    $$ = v->var;
  }
| FUNCTION '(' REALS ')'
  {
    function_class const *f = $1;
    ast_real_vect *ops = $3;
    if (f->type == UOP_ID && ops->size() != 1 ||
        f->type != UOP_ID && f->type != COP_FMA && ops->size() != 2 ||
        f->type == COP_FMA && ops->size() != 3)
      failure("incorrect number of arguments when calling " << f->name());
    $$ = normalize(ast_real(real_op(f, *ops)));
    delete ops;
  }
| REAL '+' REAL		{ $$ = rnd_normalize(ast_real(real_op($1, BOP_ADD, $3))); }
| REAL '-' REAL		{ $$ = rnd_normalize(ast_real(real_op($1, BOP_SUB, $3))); }
| REAL '*' REAL		{ $$ = rnd_normalize(ast_real(real_op($1, BOP_MUL, $3))); }
| REAL '/' REAL		{ $$ = rnd_normalize(ast_real(real_op($1, BOP_DIV, $3))); }
| '|' REAL '|'		{ $$ = normalize(ast_real(real_op(UOP_ABS, $2))); }
| SQRT '(' REAL ')'	{ $$ = rnd_normalize(ast_real(real_op(UOP_SQRT, $3))); }
| FMA '(' REAL ',' REAL ',' REAL ')'
  {
    if (!parameter_rfma)
      $$ = rnd_normalize(ast_real(real_op(normalize(ast_real(real_op($3, BOP_MUL, $5))), BOP_ADD, $7)));
    else
      $$ = rnd_normalize(ast_real(real_op($7, BOP_ADD, normalize(ast_real(real_op($3, BOP_MUL, $5))))));
  }
| '(' REAL ')'		{ $$ = $2; }
| '+' REAL %prec NEG	{ $$ = $2; }
| '-' REAL %prec NEG	{ $$ = rnd_normalize(ast_real(real_op(UOP_NEG, $2))); }

REALS:
  REAL		{ $$ = new ast_real_vect(1, $1); }
| REALS ',' REAL
  {
    $1->push_back($3);
    $$ = $1;
  }

DPOINTS:
  '(' SNUMBER		{ $$ = fill_splitter(0, $2); }
| DPOINTS ',' SNUMBER	{ $$ = fill_splitter($1, $3); }
| DPOINTS ')'		{ $$ = $1; }

DVAR:
  REAL			{ dichotomy_var v = { $1, 0 }; $$ = v; }
| REAL IN NUMBER	{ scan_integer($3, w); dichotomy_var v = { $1, w }; $$ = v; }
| REAL IN DPOINTS	{ dichotomy_var v = { $1, $3 }; $$ = v; }

DVARS:
  DVAR		{ $$ = new dvar_vect(1, $1); }
| DVARS ',' DVAR
  {
    $1->push_back($3);
    $$ = $1;
  }

HINTS:
| HINTS REAL IMPL REAL ';'
  {
    ast_real const *r1 = $2, *r2 = $4;
    test_ringularity(r1, r2);
    std::string info;
    int t = test_rewriting(r1, r2, info);
    if (t == 1) {
      warning("no need for the rewriting");
      std::cerr << "  if one of the following relations is present\n" << info;
    } else if (t == 2) {
      warning("no need for the rewriting");
      if (!info.empty())
        std::cerr << "  if all the following properties can be proved\n" << info;
    }
    register_user_rewrite(r1, r2);
  }
| HINTS REALS '$' DVARS ';'
  {
    dichotomy_hint h;
    h.dst = *$2; delete $2;
    h.src = *$4; delete $4;
    dichotomies.push_back(h);
  }
| HINTS '$' DVARS ';'
  {
    dichotomy_hint h;
    h.src = *$3; delete $3;
    dichotomies.push_back(h);
  }
| HINTS REAL '~' REAL ';'
  {
    if (accurates[$2].insert($4).second)
      approximates[$4].insert($2);
    else
      warning("relation already known");
  }

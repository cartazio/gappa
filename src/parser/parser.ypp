%{

#include <iostream>
#include "parser/ast.hpp"
#include "proofs/basic_proof.hpp"
#include "proofs/dichotomy.hpp"

int yylex(void);

int yyerror(char* errstr) {
    std::cerr << "Error: " << errstr << std::endl;
    return EXIT_FAILURE;
}

extern ast_real const *check_real(ast_ident *v);
extern void check_variable(ast_ident *v, ast_real const *r);
extern ast_prop_and merge_prop_and(ast_prop const &p1, ast_prop const &p2);
extern void generate_graph(ast_prop const &p);

ast_number *toggle_sign(ast_number const *nn) {
  ast_number n = *nn;
  if (n.base) {
    char &c = n.mantissa[0];
    c = c == '+' ? '-' : '+';
  }
  return normalize(n);
}

%}

%error-verbose

%token IDENT NUMBER IN AND IMPL

%union {
  ast_number		*number;
  ast_ident		*ident;
  ast_interval		interval;
  ast_real const	*real;
  ast_real_vect		*operands;
  ast_prop		*prop;
}

%type <prop>      ATOM
%type <number>    NUMBER
%type <number>    SNUMBER
%type <ident>     IDENT
%type <interval>  INTERVAL
%type <real>      REAL
%type <operands>  OPERANDS
%type <prop>      PROP

%right IMPL
%left AND
%left '+' '-'
%left '*' '/'
%left NEG

%%

BLOB: PROG '{' PROP '}' REWRITE { generate_graph(*$3); delete $3; }

PROP:
  ATOM			{ $$ = $1; }
| '(' PROP ')'		{ $$ = $2; }
| PROP AND PROP		{ $$ = $1; *$1 = merge_prop_and(*$1, *$3); delete $3; }
| PROP IMPL PROP
  {
    if (ast_prop_impl *p = boost::get< ast_prop_impl >($3)) {
      p->left = merge_prop_and(*$1, p->left);
      delete $1;
      $$ = $3;
    } else {
      ast_prop_impl p;
      p.left = *$1;
      p.right = *$3;
      *$1 = p;
      delete $3;
      $$ = $1;
    }
  }

SNUMBER:
  NUMBER	{ $$ = $1; }
| '+' NUMBER	{ $$ = $2; }
| '-' NUMBER	{ $$ = toggle_sign($2); }

INTERVAL:
  '[' SNUMBER ',' SNUMBER ']'	{ ast_interval i = { $2, $4 }; $$ = i; }
| '?'				{ ast_interval i = { NULL, NULL }; $$ = i; }

ATOM:
  REAL IN INTERVAL
  { $$ = new ast_prop(ast_atom_bound($1, $3)); }

PROG: | PROG IDENT '=' REAL ';'	{ check_variable($2, $4); }

REAL:
  NUMBER		{ $$ = normalize(ast_real($1)); }
| IDENT			{ $$ = check_real($1); }
| IDENT '(' OPERANDS ')'
  {
    ast_ident *f = $1;
    if (f->id_type != REAL_FUN)
      { std::cerr << "Error: " << f->name << " is not a function\n"; exit(1); }
    function const *fun = f->fun;
    ast_real_vect *ops = $3;
    $$ = normalize(ast_real(real_op(ROP_UNK, *ops)));
    delete ops;
  }
| '<' IDENT '>' '(' REAL ')'
  {
    ast_ident *r = $2;
    if (r->id_type != REAL_RND)
      { std::cerr << "Error: " << r->name << " is not a rounding\n"; exit(1); }
    $$ = normalize(ast_real(rounded_real($5, r->rnd)));
  }
| REAL '+' REAL		{ $$ = normalize(ast_real(real_op($1, BOP_ADD, $3))); }
| REAL '-' REAL		{ $$ = normalize(ast_real(real_op($1, BOP_SUB, $3))); }
| REAL '*' REAL		{ $$ = normalize(ast_real(real_op($1, BOP_MUL, $3))); }
| REAL '/' REAL		{ $$ = normalize(ast_real(real_op($1, BOP_DIV, $3))); }
| '(' REAL ')'		{ $$ = $2; }
| '+' REAL %prec NEG	{ $$ = $2; }
| '-' REAL %prec NEG
  {
    if (ast_number const *const *n = boost::get< ast_number const *const >($2))
      $$ = normalize(ast_real(toggle_sign(*n)));
    else $$ = normalize(ast_real(real_op(UOP_MINUS, $2)));
  }

OPERANDS:
  REAL
  {
    ast_real_vect *o = new ast_real_vect;
    o->push_back($1);
    $$ = o;
  }
| OPERANDS ',' REAL
  {
    $1->push_back($3);
    $$ = $1;
  }

REWRITE:
| REWRITE REAL IMPL REAL ';'	{ register_user_rewrite($2, $4); }
| REWRITE REAL '$' REAL ';'	{ register_user_dichotomy($2, $4); }

%{
#define yyerror(msg) my_yyerror(yylloc, msg)

#include "parser/ast.hpp"
#include "parser/parser.h"
#include "proofs/basic_proof.hpp"
#include "proofs/dichotomy.hpp"

#include <iostream>

int yylex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param);

int my_yyerror(YYLTYPE &yylloc, char const *errstr) {
    std::cerr << "Error: " << errstr << " at line " << yylloc.first_line << " column " << yylloc.first_column << '\n';
    return EXIT_FAILURE;
}

extern ast_real const *check_real(ast_ident *v);
extern void check_variable(ast_ident *v, ast_real const *r);
extern void check_rounding(ast_ident *v, rounding_class const *r);
extern ast_prop_and merge_prop_and(ast_prop const &p1, ast_prop const &p2);
extern void generate_graph(ast_prop const &p);
extern void test_ringularity(ast_real const *, ast_real const *);

ast_number *negative_number(ast_number *nn) {
  if (nn->base == 0) return nn;
  ast_number n = *nn;
  char &c = n.mantissa[0];
  assert(c == '+');
  c = '-';
  return normalize(n);
}

static rounding_class const *rounding_mode = NULL;

static ast_real const *rnd_normalize(ast_real const &real) {
  ast_real const *r = normalize(real);
  if (!rounding_mode) return r;
  if (rounded_real const *rr = boost::get< rounded_real const >(r))
    if (rr->rounding == rounding_mode) return r;
  return normalize(ast_real(rounded_real(r, rounding_mode)));
}

%}

%error-verbose
%pure-parser
%locations

%token IDENT NUMBER IN AND IMPL

%union {
  ast_number		*number;
  ast_ident		*ident;
  ast_interval		interval;
  ast_real const	*real;
  ast_real_vect		*operands;
  ast_prop		*prop;
  rounding_class const	*rounding;
  rounding_params	*params;
}

%type <prop>      ATOM
%type <number>    NUMBER
%type <number>    SNUMBER
%type <ident>     IDENT
%type <interval>  INTERVAL
%type <real>      REAL
%type <operands>  OPERANDS
%type <prop>      PROP
%type <rounding>  ROUNDING
%type <params>    ROUNDING_PARAMS

%right IMPL
%left AND
%left '+' '-'
%left '*' '/'
%left NEG

%%

BLOB: PROG '{' PROP '}' REWRITE { generate_graph(*$3); delete $3; }

PROP:
  ATOM			{ $$ = $1; }
| '(' PROP ')'		{ $$ = $2; }
| PROP AND PROP		{ $$ = $1; *$1 = merge_prop_and(*$1, *$3); delete $3; }
| PROP IMPL PROP
  {
    if (ast_prop_impl *p = boost::get< ast_prop_impl >($3)) {
      p->left = merge_prop_and(*$1, p->left);
      delete $1;
      $$ = $3;
    } else {
      ast_prop_impl p;
      p.left = *$1;
      p.right = *$3;
      *$1 = p;
      delete $3;
      $$ = $1;
    }
  }

SNUMBER:
  NUMBER	{ $$ = $1; }
| '+' NUMBER	{ $$ = $2; }
| '-' NUMBER	{ $$ = negative_number($2); }

INTERVAL:
  '[' SNUMBER ',' SNUMBER ']'	{ ast_interval i = { $2, $4 }; $$ = i; }
| '?'				{ ast_interval i = { NULL, NULL }; $$ = i; }

ATOM:
  REAL IN INTERVAL
  { $$ = new ast_prop(ast_atom_bound($1, $3)); }

ROUNDING_PARAMS:
  { $$ = NULL; }
| ROUNDING_PARAMS ',' NUMBER
  {
    rounding_params *p = $1;
    if (!p) p = new rounding_params;
    p->push_back(atoi($3->mantissa.c_str()));
    $$ = p;
  }

ROUNDING: '<' IDENT ROUNDING_PARAMS '>'
  {
    ast_ident *r = $2;
    if (r->id_type != REAL_RND)
      { std::cerr << "Error: " << r->name << " is not a rounding\n"; exit(1); }
    rounding_class const *rnd;
    if (rounding_params *p = $3) {
      rnd = (*r->rnd)(*p);
      delete p;
    } else
      rnd = (*r->rnd)();
    if (!rnd) {
      yyerror("invalid parameters");
      YYERROR;
    }
    $$ = rnd;
  }

EQUAL:
  '='
| ROUNDING '='	{ rounding_mode = $1; }

PROG:
| PROG IDENT EQUAL REAL ';'
  {
    check_variable($2, $4);
    rounding_mode = NULL;
  }
| PROG '<' IDENT '>' '=' ROUNDING ';'
  {
    check_rounding($3, $6);
  }

REAL:
  SNUMBER		{ $$ = normalize(ast_real($1)); }
| IDENT			{ $$ = check_real($1); }
| IDENT '(' OPERANDS ')'
  {
    ast_ident *f = $1;
    if (f->id_type != REAL_FUN)
      { std::cerr << "Error: " << f->name << " is not a function\n"; exit(1); }
    function const *fun = f->fun;
    ast_real_vect *ops = $3;
    $$ = rnd_normalize(ast_real(real_op(ROP_UNK, *ops)));
    delete ops;
  }
| ROUNDING '(' REAL ')'	{ $$ = rnd_normalize(ast_real(rounded_real($3, $1))); }
| REAL '+' REAL		{ $$ = rnd_normalize(ast_real(real_op($1, BOP_ADD, $3))); }
| REAL '-' REAL		{ $$ = rnd_normalize(ast_real(real_op($1, BOP_SUB, $3))); }
| REAL '*' REAL		{ $$ = rnd_normalize(ast_real(real_op($1, BOP_MUL, $3))); }
| REAL '/' REAL		{ $$ = rnd_normalize(ast_real(real_op($1, BOP_DIV, $3))); }
| '|' REAL '|'		{ $$ = rnd_normalize(ast_real(real_op(UOP_ABS, $2))); }
| '(' REAL ')'		{ $$ = $2; }
| '+' REAL %prec NEG	{ $$ = $2; }
| '-' REAL %prec NEG	{ $$ = rnd_normalize(ast_real(real_op(UOP_MINUS, $2))); }

OPERANDS:
  REAL
  {
    ast_real_vect *o = new ast_real_vect;
    o->push_back($1);
    $$ = o;
  }
| OPERANDS ',' REAL
  {
    $1->push_back($3);
    $$ = $1;
  }

REWRITE:
| REWRITE REAL IMPL REAL ';'
  {
    ast_real const *r1 = $2, *r2 = $4;
    test_ringularity(r1, r2);
    register_user_rewrite(r1, r2);
  }
| REWRITE REAL '$' REAL ';'	{ register_user_dichotomy($2, $4); }

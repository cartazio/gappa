%{
#include <iostream>

#include "parser/ast.hpp"
#include "parser/parser.h"
#include "proofs/basic_proof.hpp"
#include "proofs/dichotomy.hpp"

#define yyerror(msg) my_yyerror(yylloc, msg)

int yylex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param);

#define error(msg) \
  std::cerr << "Error: " << msg << " at line " << yylloc.first_line << " column " << yylloc.first_column << '\n'
#define warning(msg) \
  std::cerr << "Warning: " << msg << " at line " << yylloc.first_line << " column " << yylloc.first_column << '\n'

int my_yyerror(YYLTYPE &yylloc, char const *errstr) {
    error(errstr);
    return EXIT_FAILURE;
}

#define failure(msg) do {\
  error(msg); \
  YYERROR; \
} while (0)

extern ast_prop_and merge_prop_and(ast_prop const &p1, ast_prop const &p2);
extern void generate_graph(ast_prop const &p);
extern void test_ringularity(ast_real const *, ast_real const *);

ast_number *negative_number(ast_number *nn) {
  if (nn->base == 0) return nn;
  ast_number n = *nn;
  char &c = n.mantissa[0];
  assert(c == '+');
  c = '-';
  return normalize(n);
}

static function_class const *rounding_mode = NULL;

static ast_real const *rnd_normalize(ast_real const &real) {
  ast_real const *r = normalize(real);
  if (!rounding_mode) return r;
  return normalize(ast_real(real_op(rounding_mode, r)));
}

%}

%error-verbose
%pure-parser
%locations

%token IDENT NUMBER IN AND IMPL

%union {
  ast_number		*number;
  ast_ident		*ident;
  ast_interval		interval;
  ast_real const	*real;
  ast_real_vect		*operands;
  ast_prop		*prop;
  function_class const	*function;
  function_params	*params;
  unsigned long		param;
}

%type <prop>		ATOM
%type <number>		NUMBER
%type <number>		SNUMBER
%type <ident>		IDENT
%type <interval>	INTERVAL
%type <real>		REAL
%type <operands>	OPERANDS
%type <prop>		PROP
%type <function>	ROUNDING
%type <params>		FUNCTION_PARAMS
%type <params>		FUNCTION_PARAMS_AUX
%type <param>		FUNCTION_PARAM

%right IMPL
%left AND
%left '+' '-'
%left '*' '/'
%left NEG

%%

BLOB: PROG '{' PROP '}' REWRITE { generate_graph(*$3); delete $3; }

PROP:
  ATOM			{ $$ = $1; }
| '(' PROP ')'		{ $$ = $2; }
| PROP AND PROP		{ $$ = $1; *$1 = merge_prop_and(*$1, *$3); delete $3; }
| PROP IMPL PROP
  {
    if (ast_prop_impl *p = boost::get< ast_prop_impl >($3)) {
      p->left = merge_prop_and(*$1, p->left);
      delete $1;
      $$ = $3;
    } else {
      ast_prop_impl p;
      p.left = *$1;
      p.right = *$3;
      *$1 = p;
      delete $3;
      $$ = $1;
    }
  }

SNUMBER:
  NUMBER	{ $$ = $1; }
| '+' NUMBER	{ $$ = $2; }
| '-' NUMBER	{ $$ = negative_number($2); }

INTERVAL:
  '[' SNUMBER ',' SNUMBER ']'	{ ast_interval i = { $2, $4 }; $$ = i; }
| '?'				{ ast_interval i = { NULL, NULL }; $$ = i; }

ATOM:
  REAL IN INTERVAL
  { $$ = new ast_prop(ast_atom_bound($1, $3)); }

FUNCTION_PARAM:
  SNUMBER	{ $$ = (unsigned long)(atoi($1->mantissa.c_str()) * 2) | 1; }
| IDENT		{ $$ = (unsigned long)($1); }

FUNCTION_PARAMS_AUX:
  FUNCTION_PARAM	{ $$ = new function_params(1, $1); }
| FUNCTION_PARAMS_AUX ',' FUNCTION_PARAM
  {
    function_params *p = $1;
    p->push_back($3);
    $$ = p;
  }

FUNCTION_PARAMS:
  { $$ = NULL; }
| '<' FUNCTION_PARAMS_AUX '>'	{ $$ = $2; }

ROUNDING: '<' FUNCTION_PARAMS_AUX '>'
  {
    function_params *p = $2;
    unsigned long l = (*p)[0];
    if (l & 1) failure("first rounding parameter is not an identifier");
    ast_ident *r = (ast_ident *)(l);
    function_generator const *fun = r->fun;
    if (!fun) failure(r->name << " is not a rounding");
    function_class const *f = (*fun)(function_params(++(p->begin()), p->end()));
    delete p;
    if (!f) failure("invalid parameters for " << r->name);
    else if (f->type != UOP_ID) failure(r->name << " is not a rounding");
    $$ = f;
  }

EQUAL:
  '='
| ROUNDING '='	{ rounding_mode = $1; }

PROG:
| PROG IDENT EQUAL REAL ';'
  {
    ast_ident *v = $2;
    if (v->var) failure("the symbol " << v->name << " is already defined");
    ast_real const *r = $4;
    v->var = r;
    if (r->name) warning(r->name->name << " is being renamed to " << v->name);
    r->name = v;
    rounding_mode = NULL;
  }
| PROG '<' IDENT '>' '=' ROUNDING ';'
  {
    ast_ident *v = $3;
    if (v->fun) failure("the function " << v->name << " is already defined");
    v->fun = new default_function_generator($6);
  }

REAL:
  SNUMBER	{ $$ = normalize(ast_real($1)); }
| IDENT
  {
    ast_ident *v = $1;
    if (!v->var)
      v->var = normalize(ast_real(v));
    $$ = v->var;
  }
| IDENT FUNCTION_PARAMS '(' OPERANDS ')'
  {
    ast_ident *r = $1;
    function_generator const *fun = r->fun;
    if (!fun) failure(r->name << " is not a function");
    function_class const *f;
    if (function_params *p = $2) {
      f = (*fun)(*p);
      delete p;
    } else f = (*fun)(function_params());
    if (!f) failure("invalid parameters for " << r->name);
    ast_real_vect *ops = $4;
    if (f->type == UOP_ID && ops->size() != 1 || f->type != UOP_ID && ops->size() != 2)
      failure("incorrect number of arguments when calling " << r->name);
    $$ = rnd_normalize(ast_real(real_op(f, *ops)));
    delete ops;
  }
| ROUNDING '(' REAL ')'	{ $$ = rnd_normalize(ast_real(real_op($1, $3))); }
| REAL '+' REAL		{ $$ = rnd_normalize(ast_real(real_op($1, BOP_ADD, $3))); }
| REAL '-' REAL		{ $$ = rnd_normalize(ast_real(real_op($1, BOP_SUB, $3))); }
| REAL '*' REAL		{ $$ = rnd_normalize(ast_real(real_op($1, BOP_MUL, $3))); }
| REAL '/' REAL		{ $$ = rnd_normalize(ast_real(real_op($1, BOP_DIV, $3))); }
| '|' REAL '|'		{ $$ = rnd_normalize(ast_real(real_op(UOP_ABS, $2))); }
| '(' REAL ')'		{ $$ = $2; }
| '+' REAL %prec NEG	{ $$ = $2; }
| '-' REAL %prec NEG	{ $$ = rnd_normalize(ast_real(real_op(UOP_NEG, $2))); }

OPERANDS:
  REAL		{ $$ = new ast_real_vect(1, $1); }
| OPERANDS ',' REAL
  {
    $1->push_back($3);
    $$ = $1;
  }

REWRITE:
| REWRITE REAL IMPL REAL ';'
  {
    ast_real const *r1 = $2, *r2 = $4;
    test_ringularity(r1, r2);
    register_user_rewrite(r1, r2);
  }
| REWRITE REAL '$' REAL ';'	{ register_user_dichotomy($2, $4); }
